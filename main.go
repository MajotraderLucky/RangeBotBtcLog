package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/MajotraderLucky/MarketRepository/initlog"
	"github.com/MajotraderLucky/MarketRepository/klinesdata"
	"github.com/MajotraderLucky/MarketRepository/orderinfolog"
	"github.com/MajotraderLucky/MarketRepository/positionlog"
	"github.com/MajotraderLucky/MarketRepository/tradinglog"
	"github.com/MajotraderLucky/MarketRepository/transactions"
	"github.com/MajotraderLucky/Utils/logger"
)

func createCountersDirectory() error {
	dirPath := "counters"
	filePath := dirPath + "/cyclecounter.json"
	isNewFile := false // flag to track if the file was just created

	// Check if the directory exists
	_, err := os.Stat(dirPath)
	if os.IsNotExist(err) {
		// Create the counters directory
		err := os.Mkdir(dirPath, 0644)
		if err != nil {
			log.Printf("failed to create counters directory: %v", err)
			return fmt.Errorf("failed to create counters directory: %v", err)
		}
		log.Println("Counters directory created successfully")
	} else if err != nil {
		return fmt.Errorf("error checking existence of counters directory: %v", err)
	} else {
		log.Println("Counters directory already exists")
	}

	// Check if the file exists
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		isNewFile = true // set the flag to true if the file does not exist
		// Create the "ordersconfig.json" file with read and write permissions
		file, err := os.OpenFile(filePath, os.O_RDWR|os.O_CREATE, 0664)
		if err != nil {
			log.Fatal("Failed to create 'cyclecounter.json' file:", err)
		}
		defer file.Close()
	} else {
		log.Println("File already exists")
	}

	// Write 1 as int to the file only if the file was just created
	if isNewFile {
		file, err := os.OpenFile(filePath, os.O_RDWR|os.O_CREATE, 0664)
		if err != nil {
			log.Fatal("Failed to open 'cyclecounter.json' file:", err)
		}
		defer file.Close()

		counter := 1
		err = json.NewEncoder(file).Encode(counter)
		if err != nil {
			log.Printf("failed to write to file: %v", err)
			return fmt.Errorf("failed to write to file: %v", err)
		}
		log.Println("1 written to file successfully")
	}

	return nil
}

func main() {
	var file *os.File
	for range time.Tick(time.Second * 60) {
		logger := logger.Logger{}
		err := logger.CreateLogsDir()
		if err != nil {
			log.Fatal(err)
		}
		err = logger.OpenLogFile()
		if err != nil {
			log.Fatal(err)
		}
		logger.SetLogger()
		logger.LogLine()

		// If all files are found, start the program
		if initlog.CheckFilesExist() {
			log.Println("----------All files found, starting program----------")
		}

		log.Println("Btc bot started...")

		initlog.Init()

		autoGeneratedPos := positionlog.GetAutoGeneratedPos()
		hasOpenPos := positionlog.IsOpenPositions(autoGeneratedPos)
		log.Println("Has open positions: ", hasOpenPos)
		positionlog.GetOpenPositionVolume(autoGeneratedPos)

		logger.LogLine()

		positionlog.WritePositionsToFile(autoGeneratedPos)

		logger.LogLine()

		klinesdata.GetDebthData()
		klinesdata.KlinesInfo()
		klinesdata.FindMinMaxInfo()
		klinesdata.GetFibonacciLevelsReturns()
		klinesdata.FindPriceCorridor()
		klinesdata.IsCorridorHigher(5)

		orderinfolog.Hello()
		orderinfolog.GetOpenOrdersInfoJson()
		logger.LogLine()

		tradinglog.GetFiboLevelStartTrade()

		logger.LogLine()
		transactions.Hello()

		floLevels, err := klinesdata.GetFibonacciLevelsReturns()
		if err != nil {
			log.Fatalf("Error getting Fibonacci levels: %v", err)
		}

		intLevels, err := klinesdata.ConvertFibonacciLevelsToInts(floLevels)
		if err != nil {
			log.Fatalf("Error converting Fibonacci levels to integers: %v", err)
		}

		log.Println("Fibonacci levels to ints", intLevels)

		strLevels, err := klinesdata.ConvertIntsToStrings(intLevels)
		if err != nil {
			log.Fatalf("Error converting ints to strings: %v", err)
		}
		log.Println("Ints to strings", strLevels)

		positionAmt, entryPrice, err := positionlog.GetPositionData(autoGeneratedPos)
		if err != nil {
			log.Fatalf("Error getting position data: %v", err)
		}
		log.Println("Position Amt: ", positionAmt)
		log.Println("Entry Price: ", entryPrice)

		file, err := os.Open("logs/orders.json")
		if err != nil {
			log.Fatal(err)
		}

		openOrder382 := tradinglog.IsStartTradeLevel382Met() &&
			positionAmt == "0.000" && !orderinfolog.CheckLimitOrders(file)
		openOrder500 := tradinglog.IsStartTradeLevel500Met() &&
			positionAmt == "0.000" && !orderinfolog.CheckLimitOrders(file)
		openOrder618 := tradinglog.IsStartTradeLevel618Met() &&
			positionAmt == "0.000" && !orderinfolog.CheckLimitOrders(file)
		openOrder786 := tradinglog.IsStartTradeLevel786Met() &&
			positionAmt == "0.000" && !orderinfolog.CheckLimitOrders(file)

		openTakeProfitOrder := !orderinfolog.CheckTakeProfitMarketOrders(file) &&
			positionlog.IsOpenPositions(autoGeneratedPos)

		var takeProfitQuantity string
		var takeProfitPrice string

		if openOrder382 {
			transactions.CreateLimitOrder("0.003", strLevels[1])
			log.Println("Created limit order for level 382")
			takeProfitQuantity = "0.003"
			takeProfitPrice = strLevels[0]
			orderinfolog.CreateOrdersConfigFileAndWriteData(takeProfitQuantity, takeProfitPrice)
		}

		if openOrder500 {
			transactions.CreateLimitOrder("0.004", strLevels[2])
			log.Println("Created limit order for level 500")
			takeProfitQuantity = "0.004"
			takeProfitPrice = strLevels[1]
			orderinfolog.CreateOrdersConfigFileAndWriteData(takeProfitQuantity, takeProfitPrice)
		}

		if openOrder618 {
			transactions.CreateLimitOrder("0.005", strLevels[3])
			log.Println("Created limit order for level 618")
			takeProfitQuantity = "0.005"
			takeProfitPrice = strLevels[2]
			orderinfolog.CreateOrdersConfigFileAndWriteData(takeProfitQuantity, takeProfitPrice)
		}

		if openOrder786 {
			transactions.CreateLimitOrder("0.006", strLevels[4])
			log.Println("Created limit order for level 786")
			takeProfitQuantity = "0.006"
			takeProfitPrice = strLevels[3]
			orderinfolog.CreateOrdersConfigFileAndWriteData(takeProfitQuantity, takeProfitPrice)
		}

		openStopLossOrder382 := openOrder382 &&
			!orderinfolog.CheckStopMarketOrders(file)

		openStopLossOrder500 := openOrder500 &&
			!orderinfolog.CheckStopMarketOrders(file)

		openStopLossOrder618 := openOrder618 &&
			!orderinfolog.CheckStopMarketOrders(file)

		openStopLossOrder786 := openOrder786 &&
			!orderinfolog.CheckStopMarketOrders(file)

		maxFloat64, minFloat64, err := klinesdata.FindMinMaxInfo()
		if err != nil {
			log.Fatalf("Error finding min and max values: %v", err)
		}

		maxString, minString, err := klinesdata.ConvertMaxMinToString(maxFloat64, minFloat64)
		if err != nil {
			log.Fatalf("Error converting max and min values to strings: %v", err)
		}
		log.Println("Max: ", maxString)
		log.Println("Min: ", minString)

		transactions.ProcessStopLossOrder(openStopLossOrder382, "0.003", strLevels[2])
		transactions.ProcessStopLossOrder(openStopLossOrder500, "0.004", strLevels[3])
		transactions.ProcessStopLossOrder(openStopLossOrder618, "0.005", strLevels[4])
		transactions.ProcessStopLossOrder(openStopLossOrder786, "0.006", minString)

		log.Println("Take profit condition: ", openTakeProfitOrder)

		takeProfitQuantityFromJson, takeProfitPriceFromJson, err := orderinfolog.ReadOrdersConfig()
		if err != nil {
			log.Printf("Error reading orders config file: %v", err)
		}
		log.Println("Take profit quantity from json: ", takeProfitQuantityFromJson)
		log.Println("Take profit price from json: ", takeProfitPriceFromJson)

		if openTakeProfitOrder {
			transactions.CreatTakeProfitOrder(takeProfitQuantityFromJson, takeProfitPriceFromJson)
		}

		// The function counts arbitrary number of cyclesand,
		// if their number corresponds tothe specified one,
		// as well as there are no open positions and there
		// and there are open orders, these orders are subject
		// to cancellation
		//------------------------------------------------------------------
		if orderinfolog.CheckIfOpenOrdersExist() && !positionlog.IsOpenPositions(autoGeneratedPos) {
			log.Println("Has open orders already and not open positions")
		}

		err = createCountersDirectory()
		if err != nil {
			log.Println(err)
		}

		// -----------------------------------------------------------------

		logger.CleanLogCountLines(300)
	}
	defer file.Close()

}
