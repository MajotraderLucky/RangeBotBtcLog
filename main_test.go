package main

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"os"
	"strings"
	"testing"

	"github.com/MajotraderLucky/MarketRepository/initlog"
	"github.com/MajotraderLucky/MarketRepository/klinesdata"
	"github.com/MajotraderLucky/MarketRepository/positionlog"
	"github.com/MajotraderLucky/Utils/logger"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

func TestCheckFilesExist(t *testing.T) {
	// Perform the CheckFilesExist() function test
	result := initlog.CheckFilesExist()

	// Check that the function returns true
	assert.True(t, result)
}

func TestCreateLogsDir(t *testing.T) {
	logger := logger.Logger{}
	err := logger.CreateLogsDir()
	if err != nil {
		t.Errorf("Expected no error, but got: %v", err)
	}

	// Check that the "logs" directory was created
	_, err = os.Stat("logs")
	if os.IsNotExist(err) {
		t.Error("Expected 'logs' directory to be created, but it doesn't exist")
	}
}

func TestOpenLogFile(t *testing.T) {
	logger := logger.Logger{}
	err := logger.OpenLogFile()
	if err != nil {
		t.Errorf("Expected no error, but got: %v", err)
	}

	// Check that the log file was created
	_, err = os.Stat("logs/log.txt")
	if os.IsNotExist(err) {
		t.Error("Expected 'logs/log.txt' file to be created, but it doesn't exist")
	}
}

func TestSetLogger(t *testing.T) {
	// Create a temporary file for testing
	file, err := os.Create("test.log")
	if err != nil {
		t.Fatalf("Failed to create log file: %v", err)
	}
	defer file.Close()

	logger := logger.Logger{}
	logger.SetLogger()

	// Redirect log output to the specified file
	log.SetOutput(file)

	// Check that the log output is indeed redirected to the specified file
	log.Println("This is a test log message")

	// Reed the contents of the log file
	contents, err := os.ReadFile("test.log")
	if err != nil {
		t.Fatalf("Failed to read log file: %v", err)
	}

	// Check that the log message is present in the file
	if !strings.Contains(string(contents), "This is a test log message") {
		t.Errorf("Expected log message not found in log file")
	}
}

// Testing WritePositionsToFile with empty data and verifying file creation behavior in case of an error.
func TestWritePositionsToFile(t *testing.T) {
	data := positionlog.AutoGeneratedPos{}

	err := positionlog.WritePositionsToFile(data)
	if err == nil {
		t.Fatal("Expected an error when calling WritePositionsToFile with empty data, got no error")
	}

	data = positionlog.AutoGeneratedPos{
		Positions: []struct {
			Isolated               bool   `json:"isolated"`
			Leverage               string `json:"leverage"`
			InitialMargin          string `json:"initialMargin"`
			MaintMargin            string `json:"maintMargin"`
			OpenOrderInitialMargin string `json:"openOrderInitialMargin"`
			PositionInitialMargin  string `json:"positionInitialMargin"`
			Symbol                 string `json:"symbol"`
			UnrealizedProfit       string `json:"unrealizedProfit"`
			EntryPrice             string `json:"entryPrice"`
			MaxNotional            string `json:"maxNotional"`
			PositionSide           string `json:"positionSide"`
			PositionAmt            string `json:"positionAmt"`
			Notional               string `json:"notional"`
			IsolatedWallet         string `json:"isolatedWallet"`
			UpdateTime             int64  `json:"updateTime"`
		}{
			{
				Symbol: "ETHUSDT",
			},
		},
	}

	err = positionlog.WritePositionsToFile(data)
	if err == nil {
		t.Fatal("Expected an error when calling WritePositionsToFile with data without BTCUSDT position, got no error")
	}
}

// Create a mock for futuresClient with a predictable response
type MockFuturesClient struct {
	mock.Mock
}

func (m *MockFuturesClient) NewKlinesService() klinesdata.KlinesService {
	args := m.Called()
	return args.Get(0).(klinesdata.KlinesService)
}

type MockKlinesService struct {
	mock.Mock
}

func (m *MockKlinesService) Symbol(symbol string) klinesdata.KlinesService {
	m.Called(symbol)
	return m
}

func (m *MockKlinesService) Interval(interval string) klinesdata.KlinesService {
	m.Called(interval)
	return m
}

func (m *MockKlinesService) Do(ctx context.Context, opts ...klinesdata.RequestOption) ([]*klinesdata.Kline, error) {
	args := m.Called(ctx)
	return args.Get(0).([]*klinesdata.Kline), args.Error(1)
}

func TestFindMinMaxInfo2(t *testing.T) {
	mockClient := new(MockFuturesClient)

	expectedKlines := []*klinesdata.Kline{
		{
			High: "12000",
			Low:  "9000",
		},
	}

	mockService := new(MockKlinesService)

	// Mock function calls
	mockClient.On("NewKlinesService").Return(mockService)
	mockService.On("Symbol", "BTCUSDT").Return(mockService)
	mockService.On("Interval", "15m").Return(mockService)
	mockService.On("Do", mock.Anything).Return(expectedKlines, nil)

	max, min, err := klinesdata.FindMinMaxInfoTest(mockClient)

	// Verification assertions
	assert.NoError(t, err)
	assert.Equal(t, float64(12000), max)
	assert.Equal(t, float64(9000), min)

	// Check that the functions were called
	mockClient.AssertCalled(t, "NewKlinesService")
	mockService.AssertCalled(t, "Symbol", "BTCUSDT")
	mockService.AssertCalled(t, "Interval", "15m")
	mockService.AssertCalled(t, "Do", mock.Anything)
}

// Define the testLogger type
type testLogger struct {
	messages []string
}

func (tl *testLogger) Println(v ...interface{}) {
	message := fmt.Sprint(v...)
	tl.messages = append(tl.messages, message)
}

func (tl *testLogger) Fatalf(format string, v ...interface{}) {
	message := fmt.Sprintf(format, v...)
	tl.messages = append(tl.messages, message)
	panic(message)
}

func TestGetFibonacciLevels_ZeroRange(t *testing.T) {
	// Create a testLogger
	logger := &testLogger{}

	// Define minMaxFunc as a function
	minMaxFunc := func() (float64, float64, error) {
		return 28450, 27156, nil // Replace with the actual logic to get max and min
	}

	// Call GetFibonacciLevelsTest with the logger and minMaxFunc
	longFib236, longFib382, longFib500, longFib618, longFib786, err := klinesdata.GetFibonacciLevelsTest(logger, minMaxFunc)

	// Check for errors
	if err != nil {
		t.Errorf("Expected no error, but got: %s", err)
	}

	// Define your expected values as float64
	expectedLongFib236 := 29729.98
	expectedLongFib382 := 29117.51
	expectedLongFib500 := 28622.5
	expectedLongFib618 := 28127.49
	expectedLongFib786 := 27422.73

	// Check each Fibonacci level against the expected values
	if longFib236 != expectedLongFib236 {
		t.Errorf("Expected Fibonacci 236 level to be %v but got: %v", expectedLongFib236, longFib236)
	}

	if longFib382 != expectedLongFib382 {
		t.Errorf("Expected Fibonacci 382 level to be %v but got: %v", expectedLongFib382, longFib382)
	}

	if longFib500 != expectedLongFib500 {
		t.Errorf("Expected Fibonacci 500 level to be %v but got: %v", expectedLongFib500, longFib500)
	}

	if longFib618 != expectedLongFib618 {
		t.Errorf("Expected Fibonacci 618 level to be %v but got: %v", expectedLongFib618, longFib618)
	}

	if longFib786 != expectedLongFib786 {
		t.Errorf("Expected Fibonacci 786 level to be %v but got: %v", expectedLongFib786, longFib786)
	}
}

func TestFindPriceCorridor_NormalValues(t *testing.T) {
	// Arrange
	mockFindMinMaxInfo := func() (float64, float64, error) {
		return 20, 10, nil
	}

	mockLogger := &MockLogger{t: t}

	// Act
	priceCorridor, err := klinesdata.FindPriceCorridorTest(mockLogger, mockFindMinMaxInfo)

	// Assert
	assert.NoError(t, err)
	assert.Equal(t, 50.0, priceCorridor)
}

type MockLogger struct {
	t *testing.T
}

func (m *MockLogger) Println(v ...interface{}) {
	m.t.Logf("Println called: %v", v)
}

func (m *MockLogger) Fatalf(format string, v ...interface{}) {
	m.t.Logf("Fatalf called: format=%s, v=%v", format, v)
}

func TestCleanLogCountLines(t *testing.T) {
	l := &logger.Logger{}

	_ = l.CreateLogsDir()
	_ = l.OpenLogFile()
	l.SetLogger()

	// Записываем строки в лог с использованием log.Printf
	for i := 1; i <= 200; i++ {
		log.Printf("Log Line %d", i)
	}

	n := 100
	l.CleanLogCountLines(n)

	// Проверьте, что файл журнала содержит n строк
	data, err := os.ReadFile("logs/log.txt")
	if err != nil {
		t.Errorf("Failed to read log file: %s", err.Error())
	}

	lines := strings.Split(strings.TrimSuffix(string(data), "\n"), "\n")

	if len(lines) != n {
		t.Errorf("Expected logFile to contain %d lines but got %d lines", n, len(lines))
	}

	for i, line := range lines {
		if line == "" {
			continue
		}

		expectedSubString := fmt.Sprintf("Log Line %d", i+102)
		if !strings.Contains(line, expectedSubString) {
			t.Errorf("Expected line to contain '%s', got '%s'", expectedSubString, line)
		}
	}
}

func TestIsCorridorHigher(t *testing.T) {
	finder := &klinesdata.MockCorridorFinder{Corridor: 20.0, Err: nil}
	checker := &klinesdata.CorridorChecker{Finder: finder}

	isHigher, err := checker.IsCorridorHigherTest(10)
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
	if isHigher != true {
		t.Errorf("expected true, but got %v", isHigher)
	}
}

// Test for the IsAskPriceHigherThanLongFibRetLogTest function
type PriceGetterMock struct {
	DataFunc func() (string, string, error)
}

func (pg *PriceGetterMock) GetDebthData() (string, string, error) {
	return pg.DataFunc()
}

type FibLevelCalculatorMock struct {
	FibFunc func() ([]float64, error)
}

func (flc *FibLevelCalculatorMock) GetFibonacciLevelsReturns() ([]float64, error) {
	return flc.FibFunc()
}

func TestIsAskPriceHigherThanLongFibRetLogTest(t *testing.T) {
	pc := &klinesdata.PriceChecker{
		PGetter: &PriceGetterMock{DataFunc: func() (string, string, error) {
			// Return the data you want to use for the test
			return "100", "", nil
		}},
		FLCalculator: &FibLevelCalculatorMock{FibFunc: func() ([]float64, error) {
			// Return the data you want to use for the test
			return []float64{80, 70, 60, 50, 40}, nil
		}},
	}

	res, ok := pc.IsAskPriceHigherThanLongFibRetLogTest()
	if !ok {
		t.Fatalf("Expected true, got false")
	}

	expectedRes := "LongFib236"
	if res != expectedRes {
		t.Fatalf("Unexpected result. Expected %v, got %v", expectedRes, res)
	}
}

// -----------------------------------------------------------

type OpenOrder struct {
	OrderID string
	Symbol  string
}

type OrderInfoLogger interface {
	GetOpenOrders() ([]OpenOrder, error)
}

type MockOrderInfoLogger struct {
	ShouldFail bool
	orders     []OpenOrder
}

func (m *MockOrderInfoLogger) GetOpenOrders() ([]OpenOrder, error) {
	if m.ShouldFail {
		return nil, errors.New("mock error")
	}
	return []OpenOrder{
		{OrderID: "12345", Symbol: "BTCUSDT"},
	}, nil
}

func TestSomethingWithOpenOrder(t *testing.T) {
	var order OpenOrder
	order.OrderID = "12345"
	order.Symbol = "BTCUSDT"

	mockLogger := &MockOrderInfoLogger{}
	orders, err := mockLogger.GetOpenOrders()

	if err != nil {
		t.Fatalf("Got unexpected error: %s", err.Error())
	}

	if len(orders) == 0 || orders[0].OrderID != order.OrderID || orders[0].Symbol != order.Symbol {
		t.Fatalf("The order is not as expected: %#v", orders)
	}
}

// GetOpenOrdersInfoJsonTest gets open order info and write it as JSON to the specified file
func GetOpenOrdersInfoJsonTest(svc OrderInfoLogger, filename string) error {
	orders, err := svc.GetOpenOrders()
	if err != nil {
		return err
	}

	data, err := json.Marshal(orders)
	if err != nil {
		return err
	}

	return os.WriteFile(filename, data, 0644)
}

// ------------------------------------------------------

func TestGetOpenOrdersInfoJsonTest(t *testing.T) {
	mockOrderService := &MockOrderInfoLogger{
		orders: []OpenOrder{
			{
				OrderID: "12345",
				Symbol:  "BTCUSDT",
			},
		},
	}

	filePath := "./test_orders.json"

	err := GetOpenOrdersInfoJsonTest(mockOrderService, filePath)
	if err != nil {
		t.Fatalf("Expected no error, got %s", err.Error())
	}

	data, err := os.ReadFile(filePath)
	if err != nil {
		t.Fatalf("Failed to read test file: %s", err.Error())
	}

	var orders []OpenOrder
	err = json.Unmarshal(data, &orders)
	if err != nil || len(orders) == 0 {
		t.Fatalf("File content is not valid: %s", string(data))
	}

	found := false
	for _, order := range orders {
		if order.OrderID == "12345" && order.Symbol == "BTCUSDT" {
			found = true
			break
		}
	}

	if !found {
		t.Fatalf("Expected order not found in the output: %s", string(data))
	}

	err = os.Remove(filePath)
	if err != nil {
		t.Fatalf("Failed to clean up test file: %s", err.Error())
	}
}
